---
layout: post
title:  "[Python Chapter1 01~03]"
subtitle:   "Chapter1 01 ~ 03"
categories: language
tags: python
comments: true
---
> 본 포스팅은 **`파이썬코딩의기술`** 이라는 책을 참고하여 **개인 공부**를 하면서 정리하고 있습니다.
>
> 문제 될 시 삭제하겠습니다.

# Chapter 1
### 1.사용 중인 파이썬의 버전을 알자
- 현재 파이썬 2의 개발은 버그 수정, 보안 강화, 파이썬 2를 파이썬 3로 쉽게 **포팅(포워드세팅)**하는 기능 이외에 중지 된 상태
- 파이썬의 버전을 확인 하자

**포워드세팅**
> 즉 다른곳에 맞게 설치하는 것을 의미
윈도우에서 돌아가는 프로그램을 리눅스에서도 돌아가게 만드는
일련의 작업을 포팅이라함

### 2. PEP 8 스타일 가이드
- 파이썬 코드를 어떻게 구성할지 알려주는 스타일 가이드
- 일관성 있는 스타일 사용으로 유지보수 및 가독성에 좋다

**화이트 스페이스(공백)**

> **코드의 명료성** 때문에 민감한 편

- 탭이 아닌 스페이스로 들여씀
- 한 줄의 문자 길이가 `79자 이하`
- 표현식이 길어 다음 줄로 이어지면 `추가`로 `스페이스 네 개`를 사용
- 파일에서 함수 클래스는 빈 줄 두개로 구분
- 클래스에서는 메서드는 `빈 줄 하나`
- 리스트 인덱스, 함수 호출, 키워드 인수 할당에는 스페이스 X
- 변수 할당 앞뒤에 스페이스 하나

**명명(naming)**

- 함수, 변수, 속성을 `lowercase_underscore` 형식
- `protected` 인스턴스 속성을 `_leading_underscore`형식
- `private` 인스턴스 속성을 `__double_leading_underscore` 형식
- 모듈 수준 상수는 `ALL_CAPS` 형식

**표현식과 문장**

- 긍정 표현식의 부정(if not a is b) 대신 인라인 부정(if a is not b)을 사용
- 길이를 확인하여 빈 값([] 또는 '') 을 확인하지 않음, if not somelist를 사용, 빈 값은 암시적으로 `False`
- 비어 있지 않은 값([1] 또는 'hi')에도 위와 같은 방식이 적용, if somelist 문 암시적으로 `True`
- 현재 모듈의 경로를 기준으로 상대 경로로 된 이름을 권장하지 않지만 써야한다면 명시적 구문

	> ex) bar 패키지의 foo모듈 import => from bar import foo 또는 from . import foo

- import 순서는 `표준 라이브러리 모듈`, `서드파티 모듈`, `자신이 만든 모듈`

> TIP Pylint도구를 사용하면 정적 분석하는데 용이하다

### 3. bytes, str, unicode의 차이점을 알자
- 파이썬 3에서는 `bytes`와 `str` 두 가지 타입으로 문자 시퀀스

	> **bytes**는 인스턴스로 8비트 값 저장
- 파이썬 2에서는 `str`과 `unicode` 두 가지 타입으로 문자 시퀀스

	> 파이썬 3와는 다르게 **str** 인스턴스로 8비트 값 저장
- 파이썬 2와 3의 인스턴스는 연관된 바이너리 인코딩이 없다
- 유니코드 문자 => 바이너리 데이터  = `encode 메서드`
- 바이너리 데이터 => 유니코드 문자 = `decode 매서드`

---
**여기서 잠깐!**

- 문자나 기호들의 집합을 컴퓨터에서 저장 혹은 통신 목적으로 사용할 경우에는 `부호`로 바꾸어야 한다.
이를 `문자 인코딩(encoding)` 또는 `부호화`라고 하며 `부호화된 문자`를 복원하는 것을 `복호화`

**이진 데이터란?**
컴퓨터 저장과 처리 목적을 위해 이진 형식으로 인코딩된 데이터를 포함

---

**파이썬에서 raw 8비트 값과 유니코드 문자를 처리 할 때 중요 이슈**

- 파이썬 2에서 str이 7비트 아스키 문자만 포함하고 있다면 `unicode`와 `str` 인스턴스가 같은 타입으로 보임
- 파이썬 3에 내장 함수 open이 반환하는 파일 핸들은 기본 UTF-8 인코딩을 사용
	- 파이썬 2에서 파일 기본 연산은 `바이너리` 인코딩 사용

```python
with open('/tmp/random.bin', 'w') as f:
	f.write(os.urandom(10))

>>>
TypeError: must be str, not bytes

# 문제 발생 이유는 파이썬 3의 open에 새 encoding 인수가 추가되었기 때문
# 기본값은 'utf-8' 따라서 파일 핸들을 사용하는 read나 write 연산은
# 바이너리 데이터를 담은 bytes 인스턴스가 아니라 유니코드 문자 담은 str 인스턴스를 기대

# 이슈를 해결하려면 'w'가 아닌 바이너리 쓰기모드('wb')로 open 해야함

```
